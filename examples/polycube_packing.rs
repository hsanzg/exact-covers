//! Chapter 8 of R. Honsberger's book [_Mathematical Gems II_][mgems] (1976)
//! provides a good introduction to the techniques for solving polycube packing
//! puzzles.
//!
//! [mgems]: https://bookstore.ams.org/dol-2

use exact_covers::{DlSolver, Solver};
use smallvec::SmallVec;
use std::collections::HashSet;
use std::iter;
use std::mem::MaybeUninit;

// A point in the cubic lattice.
type Position = (i8, i8, i8);

/// A solid object formed by joining $1\times 1\times 1$ cubies face to face.
#[derive(Debug, Eq, PartialEq, Hash, Clone)]
struct Polycube(
    /// The positions occupied by the polycube.
    SmallVec<Position, { Self::INLINE_CAP }>,
);

impl Polycube {
    /// If the number of cubies in this polycube exceeds this threshold,
    /// the buffer containing their positions is allocated on the heap.
    const INLINE_CAP: usize = 5; // In this way the array of positions takes 15 bytes,
                                 // which is one less than the space required
                                 // for a 64-bit pointer and a capacity field.

    /// Creates a polycube with one or more cubies, without copying any data.
    ///
    /// This is the `const` version of [`Polycube::from`].
    pub const fn from_const(positions: [Position; Self::INLINE_CAP]) -> Self {
        Self(SmallVec::from_buf(positions))
    }

    /// Creates a polycube with one or more cubies, without copying any data.
    ///
    /// # Safety
    ///
    /// This function requires that $1\leq\text{len}\leq N$, and that all
    /// the elements in `positions[..len]` are initialized.
    pub const unsafe fn from_const_and_len_unchecked(
        positions: MaybeUninit<[Position; Self::INLINE_CAP]>,
        len: usize,
    ) -> Self {
        assert!(len > 0, "a polycube has one or more cubies");
        debug_assert!(
            len <= Self::INLINE_CAP,
            "cannot fit more than `INLINE_CAP` cubie positions on the stack"
        );
        Self(SmallVec::from_buf_and_len_unchecked(positions, len))
    }

    /// Applies a transformation to the polycube.
    pub fn transform(&self, f: impl FnMut(Position) -> Position) -> Self {
        Self(self.0.iter().copied().map(f).collect())
    }

    /// Returns the translate of the polycube whose cubie coordinates are
    /// nonnegative and as small as possible.
    ///
    /// This shape is called the _aspect_ of the polycube. Section 1.3 of
    /// the book [_Tilings and Patterns_][tap] by B. Grünbaum, G. C. Shephard
    /// (W. H. Freeman, 1987) discusses the number of distinct aspects
    /// of the tiles in particular classes of tessellations.
    ///
    /// [tap]: https://dl.acm.org/doi/10.5555/19304
    pub fn aspect(&self) -> Self {
        let x_min = self.0.iter().map(|(x, _, _)| x).min().unwrap();
        let y_min = self.0.iter().map(|(_, y, _)| y).min().unwrap();
        let z_min = self.0.iter().map(|(_, _, z)| z).min().unwrap();
        self.transform(|(x, y, z)| (x - x_min, y - y_min, z - z_min))
    }

    /// Constructs the set of aspects corresponding to all 3D-rotations of
    /// the polycube.
    ///
    /// D. E. Knuth called these the _base placements_ of a polycube in
    /// exercise 7.2.2.1.266 of [_The Art of Computer Programming_, Volume 4B,
    /// Part 2][taocp] (Addison-Wesley, 2022).
    ///
    /// [taocp]: https://www-cs-faculty.stanford.edu/~knuth/taocp.html#vol4
    pub fn base_placements(&self) -> HashSet<Polycube> {
        // The group of symmetries of a polycube is isomorphic to a subgroup of
        // the 24 3D-rotations of a cube, which is generated by the following
        // two elementary transformations:
        // 1. $90^\circ$ rotation about the $z$-axis, $(x,y,z)\mapsto(y,x_\text{max}-x,z)$.
        // 2. Reflection about the $x=y=z$ diagonal: $(x,y,z)\mapsto(y,z,x)$.
        // To see why, use the fact that the rotational symmetries of a cube
        // form a group that is isomorphic to the symmetric group $S_4$ on 4
        // elements. (Notice that the rotations of a cube permute its diagonals.)
        // In this way transformations 1 and 2 correspond respectively to
        // the permutations $\pi=(1234)$ and $\sigma=(142)$ under some
        // appropriate naming of the cube vertices. And $\{\pi,\sigma\}$ is
        // a generator of $S_4$.
        let mut placements = HashSet::with_capacity(24);
        let mut to_visit = Vec::with_capacity(8);
        to_visit.push(self.aspect());
        while let Some(shape) = to_visit.pop() {
            let x_max = shape.0.iter().map(|(x, _, _)| x).max().unwrap();
            let rotation = shape.transform(|(x, y, z)| (y, x_max - x, z));
            if !placements.contains(&rotation) {
                to_visit.push(rotation);
            }

            let reflection = shape.transform(|(x, y, z)| (y, z, x));
            if !placements.contains(&reflection) {
                to_visit.push(reflection);
            }

            placements.insert(shape);
        }
        placements
    }
}

impl From<&[Position]> for Polycube {
    /// Creates a polycube with one or more cubies.
    fn from(positions: &[Position]) -> Self {
        assert!(!positions.is_empty(), "a polycube has one or more cubies");
        Self(SmallVec::from_slice(positions))
    }
}

impl From<Vec<Position>> for Polycube {
    /// Creates a polycube with one or more cubies.
    fn from(positions: Vec<Position>) -> Self {
        assert!(!positions.is_empty(), "a polycube has one or more cubies");
        Self(positions.into())
    }
}

/// The Y pentacube, with the vector normal to its bottom face—the face that is
/// farthest-apart from the pentacube's center of mass—pointing downwards and
/// the cubie not in the long bar appearing in the up-west position.
const Y: Polycube = Polycube::from_const([(0, 2, 0), (1, 0, 0), (1, 1, 0), (1, 2, 0), (1, 3, 0)]);

/// An arrangement of polycubes in an $l\times m\times n$ cuboid.
struct Packing<const L: usize, const M: usize, const N: usize>(
    /// The polycubes within the cuboid.
    Vec<Polycube>,
);

fn is_in_bounds(polycube: &Polycube, l: i8, m: i8, n: i8) -> bool {
    let x_min = *polycube.0.iter().map(|(x, _, _)| x).min().unwrap();
    let y_min = *polycube.0.iter().map(|(_, y, _)| y).min().unwrap();
    let z_min = *polycube.0.iter().map(|(_, _, z)| z).min().unwrap();
    let x_max = *polycube.0.iter().map(|(x, _, _)| x).max().unwrap();
    let y_max = *polycube.0.iter().map(|(_, y, _)| y).max().unwrap();
    let z_max = *polycube.0.iter().map(|(_, _, z)| z).max().unwrap();
    0 <= x_min && x_max < l && 0 <= y_min && y_max < m && 0 <= z_min && z_max < n
}

fn main() {
    let (l, m, n) = (5i8, 5i8, 5i8);
    let positions = (0..l)
        .flat_map(|x| iter::repeat(x).zip(0..m))
        .flat_map(|y| iter::repeat(y).zip(0..n))
        .map(|((x, y), z)| (x, y, z))
        .collect::<Vec<_>>();

    let mut solver: DlSolver<Position, ()> = DlSolver::new(&positions, &[]);
    let placements = Y.base_placements();
    // Create one option per translated placement.
    let mut first = true;
    for placement in placements {
        for (x_0, y_0, z_0) in &positions {
            if first && (*x_0 > 2 || *y_0 > 2 || *z_0 > 2) {
                continue;
            }
            let shifted = placement.transform(|(x, y, z)| (x + x_0, y + y_0, z + z_0));
            if is_in_bounds(&shifted, l, m, n) {
                solver.add_option(&shifted.0, []);
            }
        }
        first = false;
    }

    let mut count = 0;
    let mut polycube = Vec::new();
    solver.solve(|mut solution| {
        print!("[");
        while solution.next(&mut polycube) {
            print!("[");
            if let Some((&last, elements)) = polycube.split_last() {
                for &cubie in elements {
                    print!("[{},{},{}],", cubie.0, cubie.1, cubie.2);
                }
                print!("[{},{},{}]", last.0, last.1, last.2);
            }
            print!("],");
        }
        print!("]");
        count += 1;
    });
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn y_base_placements() {
        let placements = Y.base_placements();
        assert_eq!(placements.len(), 24, "the Y pentacube has 24 3D-rotations");
        for placement in &placements {
            assert_eq!(
                placement,
                &placement.aspect(),
                "a base placement is an aspect"
            );
        }
    }
}
